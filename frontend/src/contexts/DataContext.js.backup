// contexts/DataContext.js - Global data context for managing all app data
import React, { createContext, useContext, useReducer, useEffect, useCallback } from 'react';
import apiService from '../services/apiService';

const DataContext = createContext();

// Initial state
const initialState = {
  // Farm information
  farmInfo: {
    id: 1,
    name: 'Greenfield Farm',
    location: 'California, USA',
    size: 150,
    owner: 'Demo Fra',
    established: '2020',
    status: 'active',
    description: 'Premium hay production facility',
    phone: '+1 (555) 123-4567',
    email: 'info@greenfieldfarm.com'
  },

  // Sensors data
  sensors: [],

  // Users data  
  users: [],

  // Alerts data
  alerts: [],
  
  // Current user profile
  currentUser: {
    id: 1,
    name: 'Demo Fra',
    email: 'demo@greenfieldfarm.com',
    role: 'Farm Administrator',
    phone: '+1 (555) 987-6543',
    avatar: '/api/placeholder/100/100',
    joinDate: '2020-01-15',
    lastLogin: new Date().toISOString(),
    permissions: ['all']
  },
  
  // Sensors data
  sensors: [],
  sensorsLoading: false,
  sensorsError: null,
  
  // Users data
  users: [],
  usersLoading: false,
  usersError: null,
  
  // Alerts data
  alerts: [],
  alertsLoading: false,
  alertsError: null,
  
  // KPI data
  dashboardKPIs: {
    sensorsDeployed: 0,
    activeSensors: 0,
    criticalAlerts: 0,
    balesMonitored: 1250,
    systemHealth: 0
  },
  
  teamKPIs: {
    totalUsers: 0,
    activeUsers: 0,
    adminUsers: 0
  },
  
  sensorKPIs: {
    totalSensors: 0,
    activeSensors: 0,
    offlineSensors: 0,
    lowBatterySensors: 0,
    avgTemperature: 0,
    avgMoisture: 0
  },
  
  alertsKPIs: {
    criticalAlerts: 0,
    warningAlerts: 0,
    totalNewAlerts: 0,
    resolvedToday: 0
  },
  
  // Weather data
  weather: {
    temperature: 25.3,
    humidity: 68,
    windSpeed: 12.5,
    condition: 'Partly Cloudy',
    forecast: '22°C - 28°C'
  },
  
  // Loading states
  loading: false,
  error: null
};

// Action types
const ActionTypes = {
  SET_LOADING: 'SET_LOADING',
  SET_ERROR: 'SET_ERROR',
  SET_FARM_INFO: 'SET_FARM_INFO',
  SET_CURRENT_USER: 'SET_CURRENT_USER',
  SET_SENSORS: 'SET_SENSORS',
  SET_USERS: 'SET_USERS',
  SET_ALERTS: 'SET_ALERTS',
  SET_DASHBOARD_KPIS: 'SET_DASHBOARD_KPIS',
  SET_TEAM_KPIS: 'SET_TEAM_KPIS',
  SET_SENSOR_KPIS: 'SET_SENSOR_KPIS',
  SET_ALERTS_KPIS: 'SET_ALERTS_KPIS',
  UPDATE_SENSOR: 'UPDATE_SENSOR',
  ADD_SENSOR: 'ADD_SENSOR',
  DELETE_SENSOR: 'DELETE_SENSOR',
  UPDATE_USER: 'UPDATE_USER',
  ADD_USER: 'ADD_USER',
  DELETE_USER: 'DELETE_USER'
};

// Reducer function
const dataReducer = (state, action) => {
  switch (action.type) {
    case ActionTypes.SET_LOADING:
      return { ...state, loading: action.payload };
    
    case ActionTypes.SET_ERROR:
      return { ...state, error: action.payload, loading: false };
    
    case ActionTypes.SET_FARM_INFO:
      return { ...state, farmInfo: action.payload };
    
    case ActionTypes.SET_CURRENT_USER:
      return { ...state, currentUser: action.payload };
    
    case ActionTypes.SET_SENSORS:
      return { ...state, sensors: action.payload, sensorsError: null };
    
    case ActionTypes.SET_USERS:
      return { ...state, users: action.payload, usersError: null };
    
    case ActionTypes.SET_ALERTS:
      return { ...state, alerts: action.payload, alertsError: null };
    
    case ActionTypes.SET_DASHBOARD_KPIS:
      return { ...state, dashboardKPIs: { ...state.dashboardKPIs, ...action.payload } };
    
    case ActionTypes.SET_TEAM_KPIS:
      return { ...state, teamKPIs: { ...state.teamKPIs, ...action.payload } };
    
    case ActionTypes.SET_SENSOR_KPIS:
      return { ...state, sensorKPIs: { ...state.sensorKPIs, ...action.payload } };
    
    case ActionTypes.SET_ALERTS_KPIS:
      return { ...state, alertsKPIs: { ...state.alertsKPIs, ...action.payload } };
    
const dataReducer = (state, action) => {
  switch (action.type) {
    // Sensor actions
    case 'ADD_SENSOR':
      return {
        ...state,
        sensors: Array.isArray(state.sensors) ? [...state.sensors, action.payload] : [action.payload]
      };
    
    case 'UPDATE_SENSOR':
      return {
        ...state,
        sensors: Array.isArray(state.sensors) 
          ? state.sensors.map(sensor => 
              sensor.id === action.payload.id ? action.payload : sensor
            )
          : [action.payload]
      };
    
    case 'DELETE_SENSOR':
      return {
        ...state,
        sensors: Array.isArray(state.sensors) 
          ? state.sensors.filter(sensor => sensor.id !== action.payload)
          : []
      };
    
    case 'LOAD_SENSORS':
      return {
        ...state,
        sensors: Array.isArray(action.payload) ? action.payload : []
      };

    // User actions
    case 'ADD_USER':
      return {
        ...state,
        users: Array.isArray(state.users) ? [...state.users, action.payload] : [action.payload]
      };
    
    case 'UPDATE_USER':
      return {
        ...state,
        users: Array.isArray(state.users)
          ? state.users.map(user => 
              user.id === action.payload.id ? action.payload : user
            )
          : [action.payload]
      };
    
    case 'DELETE_USER':
      return {
        ...state,
        users: Array.isArray(state.users)
          ? state.users.filter(user => user.id !== action.payload)
          : []
      };

    // Alert actions
    case 'ADD_ALERT':
      return {
        ...state,
        alerts: Array.isArray(state.alerts) ? [...state.alerts, action.payload] : [action.payload]
      };
    
    case 'UPDATE_ALERT':
      return {
        ...state,
        alerts: Array.isArray(state.alerts)
          ? state.alerts.map(alert => 
              alert.id === action.payload.id ? action.payload : alert
            )
          : [action.payload]
      };

    default:
      return state;
  }
};

// Calculate KPIs from data
const calculateKPIs = (sensors, users, alerts) => {
  const dashboardKPIs = {
    sensorsDeployed: sensors.length,
    activeSensors: sensors.filter(s => s.status === 'active').length,
    criticalAlerts: alerts.filter(a => a.severity === 'critical' && a.status === 'new').length,
    balesMonitored: 1250,
    systemHealth: sensors.length > 0 ? Math.round((sensors.filter(s => s.status === 'active').length / sensors.length) * 100) : 0
  };

  const teamKPIs = {
    totalUsers: users.length,
    activeUsers: users.filter(u => u.status === 'active').length,
    adminUsers: users.filter(u => u.role === 'admin').length
  };

  const sensorKPIs = {
    totalSensors: sensors.length,
    activeSensors: sensors.filter(s => s.status === 'active').length,
    offlineSensors: sensors.filter(s => s.status === 'offline' || s.status === 'inactive').length,
    lowBatterySensors: sensors.filter(s => s.battery < 20).length,
    avgTemperature: sensors.length > 0 ? sensors.reduce((sum, s) => sum + (s.temperature || 0), 0) / sensors.length : 0,
    avgMoisture: sensors.length > 0 ? sensors.reduce((sum, s) => sum + (s.moisture || 0), 0) / sensors.length : 0
  };

  const alertsKPIs = {
    criticalAlerts: alerts.filter(a => a.severity === 'critical' && a.status === 'new').length,
    warningAlerts: alerts.filter(a => a.severity === 'warning' && a.status === 'new').length,
    totalNewAlerts: alerts.filter(a => a.status === 'new').length,
    resolvedToday: alerts.filter(a => {
      const today = new Date().toDateString();
      return a.status === 'resolved' && new Date(a.resolvedAt || a.timestamp).toDateString() === today;
    }).length
  };

  return { dashboardKPIs, teamKPIs, sensorKPIs, alertsKPIs };
};

// Data Provider Component
export const DataProvider = ({ children }) => {
  const [state, dispatch] = useReducer(dataReducer, initialState);

  // Load initial data
  const loadData = useCallback(async () => {
    dispatch({ type: ActionTypes.SET_LOADING, payload: true });
    
    try {
      // Load sensors data
      const sensorsResponse = await apiService.getSensorsData();
      dispatch({ type: ActionTypes.SET_SENSORS, payload: sensorsResponse.data });

      // Mock users and alerts for now
      const mockUsers = [
        { id: 1, name: 'Demo Fra', email: 'demo@greenfieldfarm.com', role: 'admin', status: 'active' },
        { id: 2, name: 'John Smith', email: 'john@greenfieldfarm.com', role: 'manager', status: 'active' }
      ];
      
      const mockAlerts = [
        { id: 1, severity: 'critical', status: 'new', timestamp: new Date().toISOString() },
        { id: 2, severity: 'warning', status: 'new', timestamp: new Date().toISOString() }
      ];

      dispatch({ type: ActionTypes.SET_USERS, payload: mockUsers });
      dispatch({ type: ActionTypes.SET_ALERTS, payload: mockAlerts });

      // Calculate and update KPIs
      const kpis = calculateKPIs(sensorsResponse.data, mockUsers, mockAlerts);
      dispatch({ type: ActionTypes.SET_DASHBOARD_KPIS, payload: kpis.dashboardKPIs });
      dispatch({ type: ActionTypes.SET_TEAM_KPIS, payload: kpis.teamKPIs });
      dispatch({ type: ActionTypes.SET_SENSOR_KPIS, payload: kpis.sensorKPIs });
      dispatch({ type: ActionTypes.SET_ALERTS_KPIS, payload: kpis.alertsKPIs });

      dispatch({ type: ActionTypes.SET_LOADING, payload: false });
    } catch (error) {
      dispatch({ type: ActionTypes.SET_ERROR, payload: error.message });
    }
  }, []);

  // Sensor operations
  const addSensor = useCallback(async (sensorData) => {
    try {
      const newSensor = {
        ...sensorData,
        id: Date.now(), // Generate a unique ID
        status: 'active',
        battery: Math.floor(60 + Math.random() * 40), // Random battery 60-100%
        temperature: 20 + Math.random() * 15, // Random temp 20-35°C
        moisture: 10 + Math.random() * 10, // Random moisture 10-20%
        lastReading: new Date().toISOString(),
        minTemperature: 15 + Math.random() * 5,
        maxTemperature: 30 + Math.random() * 10,
        minMoisture: 5 + Math.random() * 5,
        maxMoisture: 15 + Math.random() * 10
      };

      // Try API call first, fallback to local update
      try {
        const response = await apiService.createSensor(newSensor);
        dispatch({ type: ActionTypes.ADD_SENSOR, payload: response.data || newSensor });
      } catch (apiError) {
        // Fallback to local update if API fails
        dispatch({ type: ActionTypes.ADD_SENSOR, payload: newSensor });
      }

      // Recalculate KPIs
      const updatedSensors = [...state.sensors, newSensor];
      const kpis = calculateKPIs(updatedSensors, state.users, state.alerts);
      dispatch({ type: ActionTypes.SET_DASHBOARD_KPIS, payload: kpis.dashboardKPIs });
      dispatch({ type: ActionTypes.SET_SENSOR_KPIS, payload: kpis.sensorKPIs });

      return newSensor;
    } catch (error) {
      throw error;
    }
  }, [state.sensors, state.users, state.alerts]);

  const updateSensor = useCallback(async (id, sensorData) => {
    try {
      const updatedSensor = { ...sensorData, id, lastReading: new Date().toISOString() };
      
      // Try API call first, fallback to local update
      try {
        const response = await apiService.updateSensor(id, updatedSensor);
        dispatch({ type: ActionTypes.UPDATE_SENSOR, payload: response.data || updatedSensor });
      } catch (apiError) {
        // Fallback to local update if API fails
        dispatch({ type: ActionTypes.UPDATE_SENSOR, payload: updatedSensor });
      }

      // Recalculate KPIs
      const updatedSensors = state.sensors.map(s => s.id === id ? updatedSensor : s);
      const kpis = calculateKPIs(updatedSensors, state.users, state.alerts);
      dispatch({ type: ActionTypes.SET_DASHBOARD_KPIS, payload: kpis.dashboardKPIs });
      dispatch({ type: ActionTypes.SET_SENSOR_KPIS, payload: kpis.sensorKPIs });

      return updatedSensor;
    } catch (error) {
      throw error;
    }
  }, [state.sensors, state.users, state.alerts]);

  const deleteSensor = useCallback(async (id) => {
    try {
      // Try API call first, fallback to local update
      try {
        await apiService.deleteSensor(id);
      } catch (apiError) {
        // Continue with local delete even if API fails
        console.warn('API delete failed, continuing with local delete');
      }
      
      dispatch({ type: ActionTypes.DELETE_SENSOR, payload: id });

      // Recalculate KPIs
      const updatedSensors = state.sensors.filter(s => s.id !== id);
      const kpis = calculateKPIs(updatedSensors, state.users, state.alerts);
      dispatch({ type: ActionTypes.SET_DASHBOARD_KPIS, payload: kpis.dashboardKPIs });
      dispatch({ type: ActionTypes.SET_SENSOR_KPIS, payload: kpis.sensorKPIs });
    } catch (error) {
      throw error;
    }
  }, [state.sensors, state.users, state.alerts]);

  // Farm operations
  const updateFarmInfo = useCallback(async (farmData) => {
    try {
      const response = await apiService.updateFarmInfo(farmData);
      dispatch({ type: ActionTypes.SET_FARM_INFO, payload: response.data });
      return response.data;
    } catch (error) {
      // For now, update locally if API fails
      dispatch({ type: ActionTypes.SET_FARM_INFO, payload: farmData });
      return farmData;
    }
  }, []);

  // Profile operations
  const updateProfile = useCallback(async (profileData) => {
    try {
      const updatedProfile = { ...state.currentUser, ...profileData };
      // TODO: Add API call for profile update
      dispatch({ type: ActionTypes.SET_CURRENT_USER, payload: updatedProfile });
      
      // Also update in localStorage for persistence
      localStorage.setItem('user', JSON.stringify(updatedProfile));
      
      return updatedProfile;
    } catch (error) {
      throw error;
    }
  }, [state.currentUser]);

  // Load initial data on mount
  useEffect(() => {
    loadData();
    
    // Load user from localStorage if available
    const savedUser = localStorage.getItem('user');
    if (savedUser) {
      try {
        const userData = JSON.parse(savedUser);
        dispatch({ type: ActionTypes.SET_CURRENT_USER, payload: { ...state.currentUser, ...userData } });
      } catch (error) {
        console.warn('Failed to parse saved user data');
      }
    }
  }, [loadData]);

  const value = {
    // State
    ...state,
    
    // Actions
    updateFarmInfo,
    updateProfile,
    addSensor,
    updateSensor,
    deleteSensor,
    loadData
  };

  return (
    <DataContext.Provider value={value}>
      {children}
    </DataContext.Provider>
  );
};

// Custom hook to use the data context
export const useData = () => {
  const context = useContext(DataContext);
  if (!context) {
    throw new Error('useData must be used within a DataProvider');
  }
  return context;
};

export default DataContext;
