{"ast":null,"code":"// src/services/dataGenerationService.js\n\nclass DataGenerationService {\n  constructor() {\n    // Load sensors from localStorage or initialize defaults\n    this.sensors = this.loadSensorsFromStorage() || this.initializeDefaultSensors();\n    this.historicalData = {};\n    this.batteryState = {};\n    this.lastGenerationTime = {};\n    this.lastReadingValues = {};\n    this.generationInterval = null;\n    this.tempIdCounter = this.loadTempIdCounter();\n\n    // Initialize historical data for paired sensors only\n    this.sensors.forEach(sensor => {\n      if (this.isSensorPaired(sensor.id)) {\n        this.initializeSensorData(sensor);\n      }\n    });\n\n    // Save sensors to localStorage\n    this.saveSensorsToStorage();\n\n    // Start automatic data generation\n    this.startAutoGeneration();\n  }\n  loadSensorsFromStorage() {\n    try {\n      const stored = localStorage.getItem('hayguard_sensors');\n      if (stored) {\n        const sensors = JSON.parse(stored);\n        // Only return if we have the default 4 paired sensors\n        const pairedSensors = sensors.filter(s => this.isSensorPaired(s.id));\n        if (pairedSensors.length > 0) {\n          return sensors;\n        }\n      }\n    } catch (error) {\n      console.error('Error loading sensors from localStorage:', error);\n    }\n    return null;\n  }\n  saveSensorsToStorage() {\n    try {\n      localStorage.setItem('hayguard_sensors', JSON.stringify(this.sensors));\n      window.dispatchEvent(new Event('sensorsUpdated'));\n    } catch (error) {\n      console.error('Error saving sensors to localStorage:', error);\n    }\n  }\n  loadTempIdCounter() {\n    try {\n      const counter = localStorage.getItem('hayguard_temp_id_counter');\n      return counter ? parseInt(counter) : 1;\n    } catch (error) {\n      return 1;\n    }\n  }\n  saveTempIdCounter() {\n    try {\n      localStorage.setItem('hayguard_temp_id_counter', this.tempIdCounter.toString());\n    } catch (error) {\n      console.error('Error saving temp ID counter:', error);\n    }\n  }\n  initializeDefaultSensors() {\n    const now = Date.now();\n    return [{\n      id: 'SENS-001',\n      name: 'Barn A Temperature & Moisture',\n      location: 'Barn A - Section 1',\n      type: 'temperature_moisture',\n      status: 'paired',\n      optimalRanges: {\n        temperature: {\n          min: 0,\n          max: 30\n        },\n        moisture: {\n          min: 12,\n          max: 18\n        }\n      },\n      balesMonitored: 45,\n      description: 'Main barn storage monitoring system',\n      initialBattery: 85,\n      qrCode: 'QR-BARN-A-001',\n      createdAt: new Date(now - 30 * 24 * 60 * 60 * 1000).toISOString(),\n      pairedAt: new Date(now - 30 * 24 * 60 * 60 * 1000).toISOString()\n    }, {\n      id: 'SENS-002',\n      name: 'Storage Unit C Climate Monitor',\n      location: 'Storage Unit C',\n      type: 'temperature_moisture',\n      status: 'paired',\n      optimalRanges: {\n        temperature: {\n          min: 0,\n          max: 25\n        },\n        moisture: {\n          min: 10,\n          max: 16\n        }\n      },\n      balesMonitored: 62,\n      description: 'Secondary storage facility monitoring',\n      initialBattery: 45,\n      qrCode: 'QR-STORAGE-C-002',\n      createdAt: new Date(now - 25 * 24 * 60 * 60 * 1000).toISOString(),\n      pairedAt: new Date(now - 25 * 24 * 60 * 60 * 1000).toISOString()\n    }, {\n      id: 'SENS-003',\n      name: 'Greenhouse A Temperature',\n      location: 'Greenhouse A - Zone 1',\n      type: 'temperature',\n      status: 'paired',\n      optimalRanges: {\n        temperature: {\n          min: 18,\n          max: 28\n        }\n      },\n      balesMonitored: 15,\n      description: 'Greenhouse climate control system',\n      initialBattery: 92,\n      qrCode: 'QR-GREENHOUSE-A-003',\n      createdAt: new Date(now - 20 * 24 * 60 * 60 * 1000).toISOString(),\n      pairedAt: new Date(now - 20 * 24 * 60 * 60 * 1000).toISOString()\n    }, {\n      id: 'SENS-004',\n      name: 'Field B Moisture Monitor',\n      location: 'Field B - Section 2',\n      type: 'moisture',\n      status: 'paired',\n      optimalRanges: {\n        moisture: {\n          min: 40,\n          max: 65\n        }\n      },\n      balesMonitored: 28,\n      description: 'Field moisture monitoring for optimal storage',\n      initialBattery: 30,\n      qrCode: 'QR-FIELD-B-004',\n      createdAt: new Date(now - 15 * 24 * 60 * 60 * 1000).toISOString(),\n      pairedAt: new Date(now - 15 * 24 * 60 * 60 * 1000).toISOString()\n    }];\n  }\n  isSensorPaired(sensorId) {\n    return sensorId && sensorId.startsWith('SENS-');\n  }\n  generateTempId() {\n    const tempId = `TEMP-${String(this.tempIdCounter).padStart(3, '0')}`;\n    this.tempIdCounter++;\n    this.saveTempIdCounter();\n    return tempId;\n  }\n  generateSensId() {\n    // Find the highest existing SENS number\n    const sensNumbers = this.sensors.filter(s => s.id.startsWith('SENS-')).map(s => parseInt(s.id.split('-')[1])).filter(n => !isNaN(n));\n    const maxNum = sensNumbers.length > 0 ? Math.max(...sensNumbers) : 0;\n    return `SENS-${String(maxNum + 1).padStart(3, '0')}`;\n  }\n  addSensor(sensorData) {\n    const tempId = this.generateTempId();\n    const newSensor = {\n      ...sensorData,\n      id: tempId,\n      status: 'unpaired',\n      createdAt: new Date().toISOString()\n    };\n    this.sensors.push(newSensor);\n    this.saveSensorsToStorage();\n    return newSensor;\n  }\n  pairSensor(tempId, qrCode) {\n    const sensorIndex = this.sensors.findIndex(s => s.id === tempId);\n    if (sensorIndex === -1) {\n      throw new Error('Sensor not found');\n    }\n    if (this.isSensorPaired(tempId)) {\n      throw new Error('Sensor is already paired');\n    }\n\n    // Generate new SENS ID\n    const sensId = this.generateSensId();\n\n    // Update sensor\n    this.sensors[sensorIndex] = {\n      ...this.sensors[sensorIndex],\n      id: sensId,\n      status: 'paired',\n      qrCode: qrCode,\n      initialBattery: 100,\n      pairedAt: new Date().toISOString()\n    };\n\n    // Initialize data generation for this sensor\n    this.initializeSensorData(this.sensors[sensorIndex]);\n\n    // Save to storage\n    this.saveSensorsToStorage();\n    return this.sensors[sensorIndex];\n  }\n  initializeSensorData(sensor) {\n    const sensorId = sensor.id;\n\n    // Calculate battery based on sensor age\n    const initialBattery = sensor.initialBattery || 100;\n    const pairedDate = new Date(sensor.pairedAt || sensor.createdAt || Date.now());\n    const daysSincePaired = (Date.now() - pairedDate.getTime()) / (1000 * 60 * 60 * 24);\n\n    // Battery depletes over 10 days (240 hours)\n    const depletionRate = this.calculateDepletionRate();\n    const hoursSincePaired = daysSincePaired * 24;\n    let currentBattery = initialBattery - hoursSincePaired * depletionRate;\n\n    // Handle battery cycling\n    const cycleHours = 240; // 10 days to full depletion\n    const chargeThreshold = 6;\n    const chargeDuration = 6; // 6 hours to recharge\n\n    let isCharging = false;\n    let chargeStartTime = null;\n    let chargePauseHours = null;\n\n    // Determine if sensor should be charging based on battery level\n    if (currentBattery <= chargeThreshold && currentBattery > 2) {\n      isCharging = true;\n      chargeStartTime = new Date();\n      chargePauseHours = 5 + Math.random() * 2; // 5-7 hours to charge\n      currentBattery = 2 + Math.random() * 4; // Show low battery while charging\n    } else if (currentBattery < 2) {\n      // Battery fully depleted, reset to 100%\n      currentBattery = 100;\n    }\n\n    // Initialize battery state\n    this.batteryState[sensorId] = {\n      level: Math.max(2, Math.min(100, currentBattery)),\n      lastChargeTime: pairedDate,\n      isCharging: isCharging,\n      chargeStartTime: chargeStartTime,\n      chargePauseHours: chargePauseHours,\n      depletionRate: depletionRate\n    };\n\n    // Initialize last reading values\n    this.lastReadingValues[sensorId] = {\n      temperature: null,\n      moisture: null\n    };\n\n    // Generate historical data\n    const daysOfHistory = Math.min(30, Math.ceil(daysSincePaired));\n    this.historicalData[sensorId] = this.generateHistoricalData(sensor, daysOfHistory);\n    this.lastGenerationTime[sensorId] = new Date();\n    console.log(`Initialized sensor ${sensorId}: Battery ${Math.round(currentBattery)}%, ${daysOfHistory} days of history`);\n  }\n  calculateDepletionRate() {\n    const daysToDepletion = 10;\n    const hoursToDepletion = daysToDepletion * 24;\n    return 100 / hoursToDepletion; // ~0.4167% per hour\n  }\n  generateHistoricalData(sensor, days) {\n    const data = [];\n    const now = new Date();\n\n    // Generate ~38 readings per day (one every 30-45 minutes)\n    const totalPoints = Math.floor(days * 38);\n    let lastTemperature = null;\n    let lastMoisture = null;\n    for (let i = totalPoints; i >= 0; i--) {\n      const intervalMinutes = 30 + Math.random() * 15; // 30-45 minute intervals\n      const timestamp = new Date(now.getTime() - i * intervalMinutes * 60 * 1000);\n      const reading = {\n        timestamp: timestamp.toISOString(),\n        sensorId: sensor.id,\n        temperature: null,\n        moisture: null,\n        battery: this.calculateHistoricalBattery(timestamp, sensor.id, sensor.initialBattery, sensor.pairedAt)\n      };\n      if (sensor.type === 'temperature' || sensor.type === 'temperature_moisture') {\n        lastTemperature = this.generateTemperature(sensor.optimalRanges.temperature, lastTemperature);\n        reading.temperature = lastTemperature;\n      }\n      if (sensor.type === 'moisture' || sensor.type === 'temperature_moisture') {\n        lastMoisture = this.generateMoisture(sensor.optimalRanges.moisture, lastMoisture);\n        reading.moisture = lastMoisture;\n      }\n      data.push(reading);\n    }\n\n    // Store the last values for continuous generation\n    this.lastReadingValues[sensor.id] = {\n      temperature: lastTemperature,\n      moisture: lastMoisture\n    };\n    return data;\n  }\n  calculateHistoricalBattery(timestamp, sensorId, initialBattery, pairedAt) {\n    const pairedDate = new Date(pairedAt);\n    const now = new Date();\n    const hoursSincePaired = (timestamp - pairedDate) / (1000 * 60 * 60);\n    const depletionRate = this.calculateDepletionRate();\n    const cycleHours = 240; // 10 days\n    const chargeThreshold = 6;\n    const chargeDuration = 6;\n    const fullCycleHours = cycleHours + chargeDuration;\n\n    // Calculate which cycle we're in\n    const cyclesCompleted = Math.floor(hoursSincePaired / fullCycleHours);\n    const hoursInCurrentCycle = hoursSincePaired % fullCycleHours;\n    let batteryLevel;\n    if (hoursInCurrentCycle < cycleHours) {\n      // Depleting phase\n      batteryLevel = initialBattery - hoursInCurrentCycle * depletionRate;\n      batteryLevel = Math.max(2, batteryLevel);\n    } else {\n      // Charging phase\n      const hoursCharging = hoursInCurrentCycle - cycleHours;\n      if (hoursCharging >= chargeDuration) {\n        // Fully charged\n        batteryLevel = 100;\n      } else {\n        // Still charging\n        batteryLevel = 2 + Math.random() * 4;\n      }\n    }\n    return Math.round(Math.max(2, Math.min(100, batteryLevel)));\n  }\n  updateBatteryLevel(sensorId) {\n    const batteryInfo = this.batteryState[sensorId];\n    if (!batteryInfo) return 100;\n    const now = new Date();\n    const hoursSinceLastUpdate = (now - this.lastGenerationTime[sensorId]) / (1000 * 60 * 60);\n    if (batteryInfo.isCharging) {\n      const hoursCharging = (now - batteryInfo.chargeStartTime) / (1000 * 60 * 60);\n      if (hoursCharging >= batteryInfo.chargePauseHours) {\n        // Finished charging\n        batteryInfo.isCharging = false;\n        batteryInfo.level = 100;\n        batteryInfo.lastChargeTime = now;\n        batteryInfo.chargePauseHours = null;\n        batteryInfo.chargeStartTime = null;\n        console.log(`Sensor ${sensorId} finished charging: 100%`);\n      } else {\n        // Still charging - show low battery level\n        batteryInfo.level = 2 + Math.random() * 4;\n      }\n    } else {\n      // Normal depletion\n      batteryInfo.level -= batteryInfo.depletionRate * hoursSinceLastUpdate;\n\n      // Check if we need to start charging\n      if (batteryInfo.level <= 6 && batteryInfo.level >= 2) {\n        batteryInfo.isCharging = true;\n        batteryInfo.chargeStartTime = now;\n        batteryInfo.chargePauseHours = 5 + Math.random() * 2; // 5-7 hours\n        batteryInfo.level = 2 + Math.random() * 4;\n        console.log(`Sensor ${sensorId} started charging: ${Math.round(batteryInfo.level)}%`);\n      }\n      batteryInfo.level = Math.max(2, batteryInfo.level);\n    }\n    return Math.round(batteryInfo.level);\n  }\n  generateTemperature(optimalRange, previousValue = null) {\n    const {\n      min,\n      max\n    } = optimalRange;\n    const range = max - min;\n    const midpoint = (min + max) / 2;\n    if (previousValue === null) {\n      const value = midpoint + (Math.random() - 0.5) * range * 0.6;\n      return parseFloat(value.toFixed(1));\n    }\n    const maxChange = Math.abs(previousValue * 0.15);\n    const isInOptimalRange = previousValue >= min && previousValue <= max;\n    const shouldBeInRange = Math.random() < 0.8;\n    let newValue;\n    if (shouldBeInRange) {\n      if (previousValue < min) {\n        const change = Math.random() * maxChange;\n        newValue = previousValue + change;\n      } else if (previousValue > max) {\n        const change = Math.random() * maxChange;\n        newValue = previousValue - change;\n      } else {\n        const change = (Math.random() - 0.5) * maxChange * 0.5;\n        newValue = previousValue + change;\n        newValue = Math.max(min, Math.min(max, newValue));\n      }\n    } else {\n      if (isInOptimalRange) {\n        const moveUp = Math.random() < 0.5;\n        const change = Math.random() * maxChange;\n        newValue = moveUp ? previousValue + change : previousValue - change;\n      } else {\n        const isAbove = previousValue > max;\n        const change = Math.random() * maxChange * 0.5;\n        newValue = isAbove ? previousValue + change : previousValue - change;\n      }\n    }\n    newValue = Math.max(0, newValue);\n    return parseFloat(newValue.toFixed(1));\n  }\n  generateMoisture(optimalRange, previousValue = null) {\n    const {\n      min,\n      max\n    } = optimalRange;\n    const range = max - min;\n    const midpoint = (min + max) / 2;\n    if (previousValue === null) {\n      const value = midpoint + (Math.random() - 0.5) * range * 0.6;\n      return parseFloat(value.toFixed(1));\n    }\n    const maxChange = Math.abs(previousValue * 0.15);\n    const isInOptimalRange = previousValue >= min && previousValue <= max;\n    const shouldBeInRange = Math.random() < 0.85;\n    let newValue;\n    if (shouldBeInRange) {\n      if (previousValue < min) {\n        const change = Math.random() * maxChange;\n        newValue = previousValue + change;\n      } else if (previousValue > max) {\n        const change = Math.random() * maxChange;\n        newValue = previousValue - change;\n      } else {\n        const change = (Math.random() - 0.5) * maxChange * 0.5;\n        newValue = previousValue + change;\n        newValue = Math.max(min, Math.min(max, newValue));\n      }\n    } else {\n      if (isInOptimalRange) {\n        const moveUp = Math.random() < 0.5;\n        const change = Math.random() * maxChange;\n        newValue = moveUp ? previousValue + change : previousValue - change;\n      } else {\n        const isAbove = previousValue > max;\n        const change = Math.random() * maxChange * 0.5;\n        newValue = isAbove ? previousValue + change : previousValue - change;\n      }\n    }\n    newValue = Math.max(0, Math.min(100, newValue));\n    return parseFloat(newValue.toFixed(1));\n  }\n  shouldGenerateData(sensorId) {\n    var _this$batteryState$se;\n    // Only generate data for paired sensors that aren't charging\n    if (!this.isSensorPaired(sensorId)) {\n      return false;\n    }\n    return !((_this$batteryState$se = this.batteryState[sensorId]) !== null && _this$batteryState$se !== void 0 && _this$batteryState$se.isCharging);\n  }\n  generateNewReading(sensor) {\n    const now = new Date();\n\n    // Don't generate for unpaired sensors\n    if (!this.isSensorPaired(sensor.id)) {\n      return null;\n    }\n\n    // Check if sensor should generate data\n    const shouldGenerate = this.shouldGenerateData(sensor.id);\n    const batteryLevel = this.updateBatteryLevel(sensor.id);\n    if (!shouldGenerate) {\n      return null;\n    }\n    const lastValues = this.lastReadingValues[sensor.id] || {\n      temperature: null,\n      moisture: null\n    };\n    const reading = {\n      timestamp: now.toISOString(),\n      sensorId: sensor.id,\n      temperature: null,\n      moisture: null,\n      battery: batteryLevel\n    };\n    if (sensor.type === 'temperature' || sensor.type === 'temperature_moisture') {\n      reading.temperature = this.generateTemperature(sensor.optimalRanges.temperature, lastValues.temperature);\n      this.lastReadingValues[sensor.id].temperature = reading.temperature;\n    }\n    if (sensor.type === 'moisture' || sensor.type === 'temperature_moisture') {\n      reading.moisture = this.generateMoisture(sensor.optimalRanges.moisture, lastValues.moisture);\n      this.lastReadingValues[sensor.id].moisture = reading.moisture;\n    }\n\n    // Add to historical data\n    this.historicalData[sensor.id].push(reading);\n\n    // Keep only last 30 days of data\n    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n    this.historicalData[sensor.id] = this.historicalData[sensor.id].filter(r => new Date(r.timestamp) > thirtyDaysAgo);\n    this.lastGenerationTime[sensor.id] = now;\n    return reading;\n  }\n  getLatestReading(sensorId) {\n    const data = this.historicalData[sensorId];\n    return data && data.length > 0 ? data[data.length - 1] : null;\n  }\n  getHistoricalData(sensorId, days = 7) {\n    var _this$historicalData$;\n    const now = new Date();\n    const cutoffDate = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);\n    return ((_this$historicalData$ = this.historicalData[sensorId]) === null || _this$historicalData$ === void 0 ? void 0 : _this$historicalData$.filter(reading => new Date(reading.timestamp) >= cutoffDate)) || [];\n  }\n  getAllSensorsWithCurrentData() {\n    return this.sensors.map(sensor => {\n      const latestReading = this.getLatestReading(sensor.id);\n      const batteryInfo = this.batteryState[sensor.id];\n\n      // Determine status\n      let status;\n      if (!this.isSensorPaired(sensor.id)) {\n        status = 'unpaired';\n      } else if (latestReading) {\n        status = 'online';\n      } else {\n        status = 'offline';\n      }\n      return {\n        ...sensor,\n        status: status,\n        currentTemperature: (latestReading === null || latestReading === void 0 ? void 0 : latestReading.temperature) || null,\n        currentMoisture: (latestReading === null || latestReading === void 0 ? void 0 : latestReading.moisture) || null,\n        batteryLevel: (latestReading === null || latestReading === void 0 ? void 0 : latestReading.battery) || (batteryInfo === null || batteryInfo === void 0 ? void 0 : batteryInfo.level) || 100,\n        isCharging: (batteryInfo === null || batteryInfo === void 0 ? void 0 : batteryInfo.isCharging) || false,\n        lastUpdate: (latestReading === null || latestReading === void 0 ? void 0 : latestReading.timestamp) || new Date().toISOString()\n      };\n    });\n  }\n  deleteSensor(sensorId) {\n    const index = this.sensors.findIndex(s => s.id === sensorId);\n    if (index !== -1) {\n      this.sensors.splice(index, 1);\n\n      // Clean up related data\n      delete this.historicalData[sensorId];\n      delete this.batteryState[sensorId];\n      delete this.lastGenerationTime[sensorId];\n      if (this.lastReadingValues) {\n        delete this.lastReadingValues[sensorId];\n      }\n      this.saveSensorsToStorage();\n      return true;\n    }\n    return false;\n  }\n  updateSensorConfig(sensorId, updates) {\n    const sensorIndex = this.sensors.findIndex(s => s.id === sensorId);\n    if (sensorIndex !== -1) {\n      this.sensors[sensorIndex] = {\n        ...this.sensors[sensorIndex],\n        ...updates\n      };\n      this.saveSensorsToStorage();\n      return this.sensors[sensorIndex];\n    }\n    return null;\n  }\n  startAutoGeneration() {\n    if (this.generationInterval) {\n      clearInterval(this.generationInterval);\n    }\n    const generateData = () => {\n      // Only generate for paired sensors\n      const pairedSensors = this.sensors.filter(s => this.isSensorPaired(s.id));\n      let generatedCount = 0;\n      pairedSensors.forEach(sensor => {\n        const reading = this.generateNewReading(sensor);\n        if (reading) {\n          generatedCount++;\n        }\n      });\n      if (generatedCount > 0) {\n        console.log(`Generated ${generatedCount} readings at ${new Date().toLocaleTimeString()}`);\n      }\n\n      // Schedule next generation (30-45 minutes)\n      const nextInterval = (30 + Math.random() * 15) * 60 * 1000;\n      setTimeout(() => {\n        generateData();\n      }, nextInterval);\n    };\n\n    // Start first generation\n    generateData();\n  }\n  generateAllReadings() {\n    const pairedSensors = this.sensors.filter(s => this.isSensorPaired(s.id));\n    let count = 0;\n    pairedSensors.forEach(sensor => {\n      const reading = this.generateNewReading(sensor);\n      if (reading) count++;\n    });\n    console.log(`Manually generated ${count} readings for ${pairedSensors.length} paired sensors`);\n    this.saveSensorsToStorage();\n  }\n\n  // Reset to default sensors (useful for testing)\n  resetToDefaults() {\n    this.sensors = this.initializeDefaultSensors();\n    this.historicalData = {};\n    this.batteryState = {};\n    this.lastGenerationTime = {};\n    this.lastReadingValues = {};\n    this.sensors.forEach(sensor => {\n      if (this.isSensorPaired(sensor.id)) {\n        this.initializeSensorData(sensor);\n      }\n    });\n    this.saveSensorsToStorage();\n    console.log('Reset to 4 default paired sensors');\n  }\n}\nconst dataGenService = new DataGenerationService();\nexport default dataGenService;","map":{"version":3,"names":["DataGenerationService","constructor","sensors","loadSensorsFromStorage","initializeDefaultSensors","historicalData","batteryState","lastGenerationTime","lastReadingValues","generationInterval","tempIdCounter","loadTempIdCounter","forEach","sensor","isSensorPaired","id","initializeSensorData","saveSensorsToStorage","startAutoGeneration","stored","localStorage","getItem","JSON","parse","pairedSensors","filter","s","length","error","console","setItem","stringify","window","dispatchEvent","Event","counter","parseInt","saveTempIdCounter","toString","now","Date","name","location","type","status","optimalRanges","temperature","min","max","moisture","balesMonitored","description","initialBattery","qrCode","createdAt","toISOString","pairedAt","sensorId","startsWith","generateTempId","tempId","String","padStart","generateSensId","sensNumbers","map","split","n","isNaN","maxNum","Math","addSensor","sensorData","newSensor","push","pairSensor","sensorIndex","findIndex","Error","sensId","pairedDate","daysSincePaired","getTime","depletionRate","calculateDepletionRate","hoursSincePaired","currentBattery","cycleHours","chargeThreshold","chargeDuration","isCharging","chargeStartTime","chargePauseHours","random","level","lastChargeTime","daysOfHistory","ceil","generateHistoricalData","log","round","daysToDepletion","hoursToDepletion","days","data","totalPoints","floor","lastTemperature","lastMoisture","i","intervalMinutes","timestamp","reading","battery","calculateHistoricalBattery","generateTemperature","generateMoisture","fullCycleHours","cyclesCompleted","hoursInCurrentCycle","batteryLevel","hoursCharging","updateBatteryLevel","batteryInfo","hoursSinceLastUpdate","optimalRange","previousValue","range","midpoint","value","parseFloat","toFixed","maxChange","abs","isInOptimalRange","shouldBeInRange","newValue","change","moveUp","isAbove","shouldGenerateData","_this$batteryState$se","generateNewReading","shouldGenerate","lastValues","thirtyDaysAgo","r","getLatestReading","getHistoricalData","_this$historicalData$","cutoffDate","getAllSensorsWithCurrentData","latestReading","currentTemperature","currentMoisture","lastUpdate","deleteSensor","index","splice","updateSensorConfig","updates","clearInterval","generateData","generatedCount","toLocaleTimeString","nextInterval","setTimeout","generateAllReadings","count","resetToDefaults","dataGenService"],"sources":["/Users/francescoterragni/Desktop/hayguard/frontend/src/services/dataGenerationService.js"],"sourcesContent":["// src/services/dataGenerationService.js\n\nclass DataGenerationService {\n  constructor() {\n    // Load sensors from localStorage or initialize defaults\n    this.sensors = this.loadSensorsFromStorage() || this.initializeDefaultSensors();\n    this.historicalData = {};\n    this.batteryState = {};\n    this.lastGenerationTime = {};\n    this.lastReadingValues = {};\n    this.generationInterval = null;\n    this.tempIdCounter = this.loadTempIdCounter();\n    \n    // Initialize historical data for paired sensors only\n    this.sensors.forEach(sensor => {\n      if (this.isSensorPaired(sensor.id)) {\n        this.initializeSensorData(sensor);\n      }\n    });\n    \n    // Save sensors to localStorage\n    this.saveSensorsToStorage();\n    \n    // Start automatic data generation\n    this.startAutoGeneration();\n  }\n\n  loadSensorsFromStorage() {\n    try {\n      const stored = localStorage.getItem('hayguard_sensors');\n      if (stored) {\n        const sensors = JSON.parse(stored);\n        // Only return if we have the default 4 paired sensors\n        const pairedSensors = sensors.filter(s => this.isSensorPaired(s.id));\n        if (pairedSensors.length > 0) {\n          return sensors;\n        }\n      }\n    } catch (error) {\n      console.error('Error loading sensors from localStorage:', error);\n    }\n    return null;\n  }\n\n  saveSensorsToStorage() {\n    try {\n      localStorage.setItem('hayguard_sensors', JSON.stringify(this.sensors));\n      window.dispatchEvent(new Event('sensorsUpdated'));\n    } catch (error) {\n      console.error('Error saving sensors to localStorage:', error);\n    }\n  }\n\n  loadTempIdCounter() {\n    try {\n      const counter = localStorage.getItem('hayguard_temp_id_counter');\n      return counter ? parseInt(counter) : 1;\n    } catch (error) {\n      return 1;\n    }\n  }\n\n  saveTempIdCounter() {\n    try {\n      localStorage.setItem('hayguard_temp_id_counter', this.tempIdCounter.toString());\n    } catch (error) {\n      console.error('Error saving temp ID counter:', error);\n    }\n  }\n\n  initializeDefaultSensors() {\n    const now = Date.now();\n    \n    return [\n      {\n        id: 'SENS-001',\n        name: 'Barn A Temperature & Moisture',\n        location: 'Barn A - Section 1',\n        type: 'temperature_moisture',\n        status: 'paired',\n        optimalRanges: {\n          temperature: { min: 0, max: 30 },\n          moisture: { min: 12, max: 18 }\n        },\n        balesMonitored: 45,\n        description: 'Main barn storage monitoring system',\n        initialBattery: 85,\n        qrCode: 'QR-BARN-A-001',\n        createdAt: new Date(now - 30 * 24 * 60 * 60 * 1000).toISOString(),\n        pairedAt: new Date(now - 30 * 24 * 60 * 60 * 1000).toISOString()\n      },\n      {\n        id: 'SENS-002',\n        name: 'Storage Unit C Climate Monitor',\n        location: 'Storage Unit C',\n        type: 'temperature_moisture',\n        status: 'paired',\n        optimalRanges: {\n          temperature: { min: 0, max: 25 },\n          moisture: { min: 10, max: 16 }\n        },\n        balesMonitored: 62,\n        description: 'Secondary storage facility monitoring',\n        initialBattery: 45,\n        qrCode: 'QR-STORAGE-C-002',\n        createdAt: new Date(now - 25 * 24 * 60 * 60 * 1000).toISOString(),\n        pairedAt: new Date(now - 25 * 24 * 60 * 60 * 1000).toISOString()\n      },\n      {\n        id: 'SENS-003',\n        name: 'Greenhouse A Temperature',\n        location: 'Greenhouse A - Zone 1',\n        type: 'temperature',\n        status: 'paired',\n        optimalRanges: {\n          temperature: { min: 18, max: 28 }\n        },\n        balesMonitored: 15,\n        description: 'Greenhouse climate control system',\n        initialBattery: 92,\n        qrCode: 'QR-GREENHOUSE-A-003',\n        createdAt: new Date(now - 20 * 24 * 60 * 60 * 1000).toISOString(),\n        pairedAt: new Date(now - 20 * 24 * 60 * 60 * 1000).toISOString()\n      },\n      {\n        id: 'SENS-004',\n        name: 'Field B Moisture Monitor',\n        location: 'Field B - Section 2',\n        type: 'moisture',\n        status: 'paired',\n        optimalRanges: {\n          moisture: { min: 40, max: 65 }\n        },\n        balesMonitored: 28,\n        description: 'Field moisture monitoring for optimal storage',\n        initialBattery: 30,\n        qrCode: 'QR-FIELD-B-004',\n        createdAt: new Date(now - 15 * 24 * 60 * 60 * 1000).toISOString(),\n        pairedAt: new Date(now - 15 * 24 * 60 * 60 * 1000).toISOString()\n      }\n    ];\n  }\n\n  isSensorPaired(sensorId) {\n    return sensorId && sensorId.startsWith('SENS-');\n  }\n\n  generateTempId() {\n    const tempId = `TEMP-${String(this.tempIdCounter).padStart(3, '0')}`;\n    this.tempIdCounter++;\n    this.saveTempIdCounter();\n    return tempId;\n  }\n\n  generateSensId() {\n    // Find the highest existing SENS number\n    const sensNumbers = this.sensors\n      .filter(s => s.id.startsWith('SENS-'))\n      .map(s => parseInt(s.id.split('-')[1]))\n      .filter(n => !isNaN(n));\n    \n    const maxNum = sensNumbers.length > 0 ? Math.max(...sensNumbers) : 0;\n    return `SENS-${String(maxNum + 1).padStart(3, '0')}`;\n  }\n\n  addSensor(sensorData) {\n    const tempId = this.generateTempId();\n    const newSensor = {\n      ...sensorData,\n      id: tempId,\n      status: 'unpaired',\n      createdAt: new Date().toISOString()\n    };\n    \n    this.sensors.push(newSensor);\n    this.saveSensorsToStorage();\n    \n    return newSensor;\n  }\n\n  pairSensor(tempId, qrCode) {\n    const sensorIndex = this.sensors.findIndex(s => s.id === tempId);\n    \n    if (sensorIndex === -1) {\n      throw new Error('Sensor not found');\n    }\n\n    if (this.isSensorPaired(tempId)) {\n      throw new Error('Sensor is already paired');\n    }\n\n    // Generate new SENS ID\n    const sensId = this.generateSensId();\n    \n    // Update sensor\n    this.sensors[sensorIndex] = {\n      ...this.sensors[sensorIndex],\n      id: sensId,\n      status: 'paired',\n      qrCode: qrCode,\n      initialBattery: 100,\n      pairedAt: new Date().toISOString()\n    };\n\n    // Initialize data generation for this sensor\n    this.initializeSensorData(this.sensors[sensorIndex]);\n    \n    // Save to storage\n    this.saveSensorsToStorage();\n\n    return this.sensors[sensorIndex];\n  }\n\n  initializeSensorData(sensor) {\n    const sensorId = sensor.id;\n    \n    // Calculate battery based on sensor age\n    const initialBattery = sensor.initialBattery || 100;\n    const pairedDate = new Date(sensor.pairedAt || sensor.createdAt || Date.now());\n    const daysSincePaired = (Date.now() - pairedDate.getTime()) / (1000 * 60 * 60 * 24);\n    \n    // Battery depletes over 10 days (240 hours)\n    const depletionRate = this.calculateDepletionRate();\n    const hoursSincePaired = daysSincePaired * 24;\n    let currentBattery = initialBattery - (hoursSincePaired * depletionRate);\n    \n    // Handle battery cycling\n    const cycleHours = 240; // 10 days to full depletion\n    const chargeThreshold = 6;\n    const chargeDuration = 6; // 6 hours to recharge\n    \n    let isCharging = false;\n    let chargeStartTime = null;\n    let chargePauseHours = null;\n    \n    // Determine if sensor should be charging based on battery level\n    if (currentBattery <= chargeThreshold && currentBattery > 2) {\n      isCharging = true;\n      chargeStartTime = new Date();\n      chargePauseHours = 5 + (Math.random() * 2); // 5-7 hours to charge\n      currentBattery = 2 + (Math.random() * 4); // Show low battery while charging\n    } else if (currentBattery < 2) {\n      // Battery fully depleted, reset to 100%\n      currentBattery = 100;\n    }\n    \n    // Initialize battery state\n    this.batteryState[sensorId] = {\n      level: Math.max(2, Math.min(100, currentBattery)),\n      lastChargeTime: pairedDate,\n      isCharging: isCharging,\n      chargeStartTime: chargeStartTime,\n      chargePauseHours: chargePauseHours,\n      depletionRate: depletionRate\n    };\n\n    // Initialize last reading values\n    this.lastReadingValues[sensorId] = {\n      temperature: null,\n      moisture: null\n    };\n\n    // Generate historical data\n    const daysOfHistory = Math.min(30, Math.ceil(daysSincePaired));\n    this.historicalData[sensorId] = this.generateHistoricalData(sensor, daysOfHistory);\n    this.lastGenerationTime[sensorId] = new Date();\n    \n    console.log(`Initialized sensor ${sensorId}: Battery ${Math.round(currentBattery)}%, ${daysOfHistory} days of history`);\n  }\n\n  calculateDepletionRate() {\n    const daysToDepletion = 10;\n    const hoursToDepletion = daysToDepletion * 24;\n    return 100 / hoursToDepletion; // ~0.4167% per hour\n  }\n\n  generateHistoricalData(sensor, days) {\n    const data = [];\n    const now = new Date();\n    \n    // Generate ~38 readings per day (one every 30-45 minutes)\n    const totalPoints = Math.floor(days * 38);\n    let lastTemperature = null;\n    let lastMoisture = null;\n\n    for (let i = totalPoints; i >= 0; i--) {\n      const intervalMinutes = 30 + Math.random() * 15; // 30-45 minute intervals\n      const timestamp = new Date(now.getTime() - (i * intervalMinutes * 60 * 1000));\n      \n      const reading = {\n        timestamp: timestamp.toISOString(),\n        sensorId: sensor.id,\n        temperature: null,\n        moisture: null,\n        battery: this.calculateHistoricalBattery(timestamp, sensor.id, sensor.initialBattery, sensor.pairedAt)\n      };\n\n      if (sensor.type === 'temperature' || sensor.type === 'temperature_moisture') {\n        lastTemperature = this.generateTemperature(\n          sensor.optimalRanges.temperature, \n          lastTemperature\n        );\n        reading.temperature = lastTemperature;\n      }\n\n      if (sensor.type === 'moisture' || sensor.type === 'temperature_moisture') {\n        lastMoisture = this.generateMoisture(\n          sensor.optimalRanges.moisture, \n          lastMoisture\n        );\n        reading.moisture = lastMoisture;\n      }\n\n      data.push(reading);\n    }\n\n    // Store the last values for continuous generation\n    this.lastReadingValues[sensor.id] = {\n      temperature: lastTemperature,\n      moisture: lastMoisture\n    };\n\n    return data;\n  }\n\n  calculateHistoricalBattery(timestamp, sensorId, initialBattery, pairedAt) {\n    const pairedDate = new Date(pairedAt);\n    const now = new Date();\n    const hoursSincePaired = (timestamp - pairedDate) / (1000 * 60 * 60);\n    \n    const depletionRate = this.calculateDepletionRate();\n    const cycleHours = 240; // 10 days\n    const chargeThreshold = 6;\n    const chargeDuration = 6;\n    const fullCycleHours = cycleHours + chargeDuration;\n\n    // Calculate which cycle we're in\n    const cyclesCompleted = Math.floor(hoursSincePaired / fullCycleHours);\n    const hoursInCurrentCycle = hoursSincePaired % fullCycleHours;\n\n    let batteryLevel;\n\n    if (hoursInCurrentCycle < cycleHours) {\n      // Depleting phase\n      batteryLevel = initialBattery - (hoursInCurrentCycle * depletionRate);\n      batteryLevel = Math.max(2, batteryLevel);\n    } else {\n      // Charging phase\n      const hoursCharging = hoursInCurrentCycle - cycleHours;\n      if (hoursCharging >= chargeDuration) {\n        // Fully charged\n        batteryLevel = 100;\n      } else {\n        // Still charging\n        batteryLevel = 2 + (Math.random() * 4);\n      }\n    }\n\n    return Math.round(Math.max(2, Math.min(100, batteryLevel)));\n  }\n\n  updateBatteryLevel(sensorId) {\n    const batteryInfo = this.batteryState[sensorId];\n    if (!batteryInfo) return 100;\n    \n    const now = new Date();\n    const hoursSinceLastUpdate = (now - this.lastGenerationTime[sensorId]) / (1000 * 60 * 60);\n\n    if (batteryInfo.isCharging) {\n      const hoursCharging = (now - batteryInfo.chargeStartTime) / (1000 * 60 * 60);\n      \n      if (hoursCharging >= batteryInfo.chargePauseHours) {\n        // Finished charging\n        batteryInfo.isCharging = false;\n        batteryInfo.level = 100;\n        batteryInfo.lastChargeTime = now;\n        batteryInfo.chargePauseHours = null;\n        batteryInfo.chargeStartTime = null;\n        console.log(`Sensor ${sensorId} finished charging: 100%`);\n      } else {\n        // Still charging - show low battery level\n        batteryInfo.level = 2 + (Math.random() * 4);\n      }\n    } else {\n      // Normal depletion\n      batteryInfo.level -= (batteryInfo.depletionRate * hoursSinceLastUpdate);\n\n      // Check if we need to start charging\n      if (batteryInfo.level <= 6 && batteryInfo.level >= 2) {\n        batteryInfo.isCharging = true;\n        batteryInfo.chargeStartTime = now;\n        batteryInfo.chargePauseHours = 5 + (Math.random() * 2); // 5-7 hours\n        batteryInfo.level = 2 + (Math.random() * 4);\n        console.log(`Sensor ${sensorId} started charging: ${Math.round(batteryInfo.level)}%`);\n      }\n\n      batteryInfo.level = Math.max(2, batteryInfo.level);\n    }\n\n    return Math.round(batteryInfo.level);\n  }\n\n  generateTemperature(optimalRange, previousValue = null) {\n    const { min, max } = optimalRange;\n    const range = max - min;\n    const midpoint = (min + max) / 2;\n    \n    if (previousValue === null) {\n      const value = midpoint + (Math.random() - 0.5) * range * 0.6;\n      return parseFloat(value.toFixed(1));\n    }\n    \n    const maxChange = Math.abs(previousValue * 0.15);\n    const isInOptimalRange = previousValue >= min && previousValue <= max;\n    const shouldBeInRange = Math.random() < 0.8;\n    \n    let newValue;\n    \n    if (shouldBeInRange) {\n      if (previousValue < min) {\n        const change = Math.random() * maxChange;\n        newValue = previousValue + change;\n      } else if (previousValue > max) {\n        const change = Math.random() * maxChange;\n        newValue = previousValue - change;\n      } else {\n        const change = (Math.random() - 0.5) * maxChange * 0.5;\n        newValue = previousValue + change;\n        newValue = Math.max(min, Math.min(max, newValue));\n      }\n    } else {\n      if (isInOptimalRange) {\n        const moveUp = Math.random() < 0.5;\n        const change = Math.random() * maxChange;\n        newValue = moveUp ? previousValue + change : previousValue - change;\n      } else {\n        const isAbove = previousValue > max;\n        const change = Math.random() * maxChange * 0.5;\n        newValue = isAbove ? previousValue + change : previousValue - change;\n      }\n    }\n    \n    newValue = Math.max(0, newValue);\n    return parseFloat(newValue.toFixed(1));\n  }\n\n  generateMoisture(optimalRange, previousValue = null) {\n    const { min, max } = optimalRange;\n    const range = max - min;\n    const midpoint = (min + max) / 2;\n    \n    if (previousValue === null) {\n      const value = midpoint + (Math.random() - 0.5) * range * 0.6;\n      return parseFloat(value.toFixed(1));\n    }\n    \n    const maxChange = Math.abs(previousValue * 0.15);\n    const isInOptimalRange = previousValue >= min && previousValue <= max;\n    const shouldBeInRange = Math.random() < 0.85;\n    \n    let newValue;\n    \n    if (shouldBeInRange) {\n      if (previousValue < min) {\n        const change = Math.random() * maxChange;\n        newValue = previousValue + change;\n      } else if (previousValue > max) {\n        const change = Math.random() * maxChange;\n        newValue = previousValue - change;\n      } else {\n        const change = (Math.random() - 0.5) * maxChange * 0.5;\n        newValue = previousValue + change;\n        newValue = Math.max(min, Math.min(max, newValue));\n      }\n    } else {\n      if (isInOptimalRange) {\n        const moveUp = Math.random() < 0.5;\n        const change = Math.random() * maxChange;\n        newValue = moveUp ? previousValue + change : previousValue - change;\n      } else {\n        const isAbove = previousValue > max;\n        const change = Math.random() * maxChange * 0.5;\n        newValue = isAbove ? previousValue + change : previousValue - change;\n      }\n    }\n    \n    newValue = Math.max(0, Math.min(100, newValue));\n    return parseFloat(newValue.toFixed(1));\n  }\n\n  shouldGenerateData(sensorId) {\n    // Only generate data for paired sensors that aren't charging\n    if (!this.isSensorPaired(sensorId)) {\n      return false;\n    }\n    return !this.batteryState[sensorId]?.isCharging;\n  }\n\n  generateNewReading(sensor) {\n    const now = new Date();\n    \n    // Don't generate for unpaired sensors\n    if (!this.isSensorPaired(sensor.id)) {\n      return null;\n    }\n\n    // Check if sensor should generate data\n    const shouldGenerate = this.shouldGenerateData(sensor.id);\n    const batteryLevel = this.updateBatteryLevel(sensor.id);\n    \n    if (!shouldGenerate) {\n      return null;\n    }\n\n    const lastValues = this.lastReadingValues[sensor.id] || { temperature: null, moisture: null };\n\n    const reading = {\n      timestamp: now.toISOString(),\n      sensorId: sensor.id,\n      temperature: null,\n      moisture: null,\n      battery: batteryLevel\n    };\n\n    if (sensor.type === 'temperature' || sensor.type === 'temperature_moisture') {\n      reading.temperature = this.generateTemperature(\n        sensor.optimalRanges.temperature,\n        lastValues.temperature\n      );\n      this.lastReadingValues[sensor.id].temperature = reading.temperature;\n    }\n\n    if (sensor.type === 'moisture' || sensor.type === 'temperature_moisture') {\n      reading.moisture = this.generateMoisture(\n        sensor.optimalRanges.moisture,\n        lastValues.moisture\n      );\n      this.lastReadingValues[sensor.id].moisture = reading.moisture;\n    }\n\n    // Add to historical data\n    this.historicalData[sensor.id].push(reading);\n    \n    // Keep only last 30 days of data\n    const thirtyDaysAgo = new Date(now.getTime() - (30 * 24 * 60 * 60 * 1000));\n    this.historicalData[sensor.id] = this.historicalData[sensor.id].filter(\n      r => new Date(r.timestamp) > thirtyDaysAgo\n    );\n\n    this.lastGenerationTime[sensor.id] = now;\n    \n    return reading;\n  }\n\n  getLatestReading(sensorId) {\n    const data = this.historicalData[sensorId];\n    return data && data.length > 0 ? data[data.length - 1] : null;\n  }\n\n  getHistoricalData(sensorId, days = 7) {\n    const now = new Date();\n    const cutoffDate = new Date(now.getTime() - (days * 24 * 60 * 60 * 1000));\n    \n    return this.historicalData[sensorId]?.filter(\n      reading => new Date(reading.timestamp) >= cutoffDate\n    ) || [];\n  }\n\n  getAllSensorsWithCurrentData() {\n    return this.sensors.map(sensor => {\n      const latestReading = this.getLatestReading(sensor.id);\n      const batteryInfo = this.batteryState[sensor.id];\n      \n      // Determine status\n      let status;\n      if (!this.isSensorPaired(sensor.id)) {\n        status = 'unpaired';\n      } else if (latestReading) {\n        status = 'online';\n      } else {\n        status = 'offline';\n      }\n      \n      return {\n        ...sensor,\n        status: status,\n        currentTemperature: latestReading?.temperature || null,\n        currentMoisture: latestReading?.moisture || null,\n        batteryLevel: latestReading?.battery || batteryInfo?.level || 100,\n        isCharging: batteryInfo?.isCharging || false,\n        lastUpdate: latestReading?.timestamp || new Date().toISOString()\n      };\n    });\n  }\n\n  deleteSensor(sensorId) {\n    const index = this.sensors.findIndex(s => s.id === sensorId);\n    if (index !== -1) {\n      this.sensors.splice(index, 1);\n      \n      // Clean up related data\n      delete this.historicalData[sensorId];\n      delete this.batteryState[sensorId];\n      delete this.lastGenerationTime[sensorId];\n      if (this.lastReadingValues) {\n        delete this.lastReadingValues[sensorId];\n      }\n      \n      this.saveSensorsToStorage();\n      return true;\n    }\n    return false;\n  }\n\n  updateSensorConfig(sensorId, updates) {\n    const sensorIndex = this.sensors.findIndex(s => s.id === sensorId);\n    if (sensorIndex !== -1) {\n      this.sensors[sensorIndex] = {\n        ...this.sensors[sensorIndex],\n        ...updates\n      };\n      this.saveSensorsToStorage();\n      return this.sensors[sensorIndex];\n    }\n    return null;\n  }\n\n  startAutoGeneration() {\n    if (this.generationInterval) {\n      clearInterval(this.generationInterval);\n    }\n\n    const generateData = () => {\n      // Only generate for paired sensors\n      const pairedSensors = this.sensors.filter(s => this.isSensorPaired(s.id));\n      \n      let generatedCount = 0;\n      pairedSensors.forEach(sensor => {\n        const reading = this.generateNewReading(sensor);\n        if (reading) {\n          generatedCount++;\n        }\n      });\n      \n      if (generatedCount > 0) {\n        console.log(`Generated ${generatedCount} readings at ${new Date().toLocaleTimeString()}`);\n      }\n      \n      // Schedule next generation (30-45 minutes)\n      const nextInterval = (30 + Math.random() * 15) * 60 * 1000;\n      \n      setTimeout(() => {\n        generateData();\n      }, nextInterval);\n    };\n\n    // Start first generation\n    generateData();\n  }\n\n  generateAllReadings() {\n    const pairedSensors = this.sensors.filter(s => this.isSensorPaired(s.id));\n    let count = 0;\n    pairedSensors.forEach(sensor => {\n      const reading = this.generateNewReading(sensor);\n      if (reading) count++;\n    });\n    console.log(`Manually generated ${count} readings for ${pairedSensors.length} paired sensors`);\n    this.saveSensorsToStorage();\n  }\n\n  // Reset to default sensors (useful for testing)\n  resetToDefaults() {\n    this.sensors = this.initializeDefaultSensors();\n    this.historicalData = {};\n    this.batteryState = {};\n    this.lastGenerationTime = {};\n    this.lastReadingValues = {};\n    \n    this.sensors.forEach(sensor => {\n      if (this.isSensorPaired(sensor.id)) {\n        this.initializeSensorData(sensor);\n      }\n    });\n    \n    this.saveSensorsToStorage();\n    console.log('Reset to 4 default paired sensors');\n  }\n}\n\nconst dataGenService = new DataGenerationService();\n\nexport default dataGenService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}